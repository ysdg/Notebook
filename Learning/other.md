# 杂记

主要记录一些不成系统的碎片化知识

## 无锁编程（Lock-Free Programming）

阅读文章《[An Introduction to Lock-Free Programming](https://preshing.com/20120612/an-introduction-to-lock-free-programming/)》,对无锁编程有了初步理解，此处简要记录。

首先，什么是无锁编程。通常，简单定义为不含互斥锁的程序。但是，此定义一方面过于狭义，不包含信号量、事件等高级锁操作。另一方面，若理解为所有互斥操作，又过于广义，对实际上的大型程序，基本不可能实现无锁编程。因此，文章重新描述了无锁编程概念，即不阻塞其他（线程）任务的执行（non-bolcking）。

个人认为，此不阻塞的无锁编程概念，较为合理。要思考其合理性，需先认识线程锁的诞生，以及解决了什么问题，又带来了什么问题。总所周知，线程锁随着多线程编程的兴起。目的是解决多线程程序中，数据同步问题。但由于解决问题的方式是阻塞线程执行，等待一方执行完成，以达到数据同步的目的。此阻塞方式，既可能造成死锁等问题，也会阻碍线程的继续执行，浪费CPU资源。因此，认为此无阻塞概念，符合编程过程中，对程序的执行预期。**即，无锁编程，是为了减少线程阻塞，提高对CPU算力的利用率**。以此为出发点，回顾写代码中，对低算力、强关联的任务切至同一线程处理，以及协程等概念，也相互呼应。同时，也能注意到，无锁编程为了保持线程不阻塞，是提高线程利用率，并不能提高线程算力。对需高算力的任务，无锁编程并不能解决耗时长的问题，仅能保证此任务不阻塞其他线程执行。对高算力任务，还需进行任务分解，并行执行，进一步利用CPU的多核算力。

最后，记录一下文中的概念：

| 概念                        | 缩写 | 含义                                                  |
| --------------------------- | ---- | ----------------------------------------------------- |
| Read-Modify-Write operation | RMW  | 允许执行读、改、写的原子性操作                        |
| Compare-And-Swap Loops      | CAS  | RMW最常见场景，即在循环中重复尝试比较和交换的事务操作 |
| Sequential Consistency      | \    | 顺序一致性，所有线程对内存的操作顺序一致              |

