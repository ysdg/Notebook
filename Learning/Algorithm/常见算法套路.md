# 常见算法套路

## 概述

本文属于对[《校招社招中的常见算法套路》](https://mp.weixin.qq.com/s/v0gbG42wcytEAjGwCctyxg)的摘抄，看到这篇文章，发现对刷Leecode极为有用。因此摘抄下来，加深自己的印象。

原文还推荐课程《Grokking the Coding Interview: Patterns for Coding Questions》。

## 算法套路

一共14中算法模式，以下每种对应一个标题。原文中包含图形化的形象描述，本文仅摘抄其思想，不处理图片。

| 算法                         | 思想                                                         | 适用场景                                                     | 常见问题                                                     |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 滑动窗口                     | 从第一个元素开始滑动窗口并逐个元素地向右滑，并根据你所求解的问题调整窗口的长度。 | 问题的输入是一种线性数据结构，比如链表、数组或字符串;<br>你被要求查找最长/最短的子字符串、子数组或所需的值; | 大小为 K 的子数组的最大和（简单）<br>带有K个不同字符的最大子字符串（中等）;<br>寻找字符相同但排序不一样的字符串（困难）; |
| 二指针或迭代器               | 两个指针以一前一后的模式在数据结构中迭代，直到一个或两个指针达到某种特定条件 | 要处理排序数组（或链接列表），并需要查找满足某些约束的一组元素；<br>数组中的元素集是配对、三元组甚至子数组； | 求一个排序数组的平方（简单）<br>求总和为零的三元组（中等）<br>比较包含回退（backspace）的字符串（中等） |
| 快速和慢速指针               | 也被称为Hare&Tortoise算法<br>两指针以不同速度进行移动（比如在一个循环链表中），使得快指针追赶上慢指针。<br>虽然都是，与**二指针或迭代器**相比，此两指针一般从同一地点出发，同向而行。而二指针或迭代器，一般从两端出发，相向而行。 | 处理链表或数组中的循环问题；<br>需要知道特定元素的位置或链表的总长度； | 链表循环（简单）<br>回文链表（中等）<br>环形数组中的循环（困难）<br> |
| 合并区间                     | 处理重叠区间                                                 | 求一个仅含互斥区间的列表；<br>包含重叠区间词汇（overlapping intervals） | 区间交叉（中等）<br>最大CPU负载（困难）                      |
| 循环排序                     | 一次循环在数组上迭代一个数值，如果所迭代的当前数值不在正确的索引处，就与正确的索引交换 | 数值在给定范围内的排序数组问题；<br>在一个排序/旋转的数组中找到缺失值/重复值/最小值； | 找到缺失值（简单）<br>找到最小的缺失正数值（中等）           |
| 原地反转链表                 | 反转链表中的节点链接，并原地完成此功能，不占用额外内存       | 反转链表，而不使用额外内存                                   | 反转一个子列表<br>反转每个K个元素的子列表                    |
| 树的宽度优先搜索（Tree BFS） | 基于宽度优先搜索(BFS)技术，可遍历一个树，并使用一个队列跟踪一个层级的所有节点，然后再转跳到下一层级 | 以逐层及方式遍历（或按层级顺序）一个树                       | 二叉树层级顺序遍历<br>之字形遍历                             |
| 树的深度优先搜索（Tree DFS） | 在遍历期间，使用递归来保持对保持对父节点的跟踪。             | 需要搜索节点中，更接近根节点（叶节点）的节点                 | 路径数量之和<br>一个和的所有路径                             |
| Two Heaps                    | 使用两个堆，一个用于寻找最小元素的min heap，另一个用来寻找最大元素的max heap | 优先级队列、调度等场景<br>需要找一个集合的最小/最大/中间元素<br>具有二叉树数据结构的问题 | 查找一个数据流的中间值                                       |
| 子集                         | 给定元素的排列和组合                                         | 需要找到给定集合的组合或排列                                 | 带有重复项的子集<br>通过改变大小写的字符串排列               |
| 经过修改的二叉搜索           | 找到起点和终点的中间位置，推荐描述：middle=start + (end - start)/2<br>如果key等于中构建索引值，则返回此位置<br>如果不等于，则判断大小，并继续上诉步骤 | 给定已排序的数据集，寻找特定元素                             | 于顺序无关的二叉搜索<br>在经过排序的无限数组中搜索           |
| 前K个元素                    | 似乎，基本都可以先排序，后直接取条件                         | 寻找给定集合中最前面的/最小的/最常出现的K个元素              | 前面的K个数<br>最常出现的K个数                               |
| K路合并                      | 1. 将每个数组的第一个元素插入min heap（条件排序集合）；<br>2. 从该heap取最小元素（条件元素），并加入合并列表<br>3. 从Heap移除该元素，并将同列表的下一个元素插入Heap<br>4. 重复2、3，支持完成 | 具有排序数组、列表和矩阵的问题<br>要求合并排序列表           | 合并K个排序的列表<br>找到和最大K个配对                       |
| 拓扑排序                     | 1. 初始化；<br>2. 构建图并找到所有顶点的in-degree；<br>3. 寻找所有的源；<br>4. 排序 | 需按照相互依赖的元素的线性顺序                               | 处理无向有环图问题<br>以排序顺序更新所有对象<br>有一类遵循特定顺序的对象 |



